/**
 * Incident Issue Creation - P17
 *
 * Creates GitHub issues for persistent critical incidents
 * Disabled by default for safety
 */

import { incidentToMarkdown, generateIncidentSummary } from './summary';
import type {
  IIncidentStateStore,
  IncidentConfig,
  IncidentState,
} from './types';
import { markIncidentIssueCreated } from './update';

/**
 * GitHub API interface (for dependency injection)
 */
export interface GitHubIssueAPI {
  createIssue(options: {
    title: string;
    body: string;
    labels?: string[];
  }): Promise<{ number: number; url: string }>;
}

/**
 * Mock GitHub API for testing
 */
export class MockGitHubIssueAPI implements GitHubIssueAPI {
  public createdIssues: Array<{
    title: string;
    body: string;
    labels?: string[];
    number: number;
    url: string;
  }> = [];

  private nextNumber = 1000;

  async createIssue(options: {
    title: string;
    body: string;
    labels?: string[];
  }): Promise<{ number: number; url: string }> {
    const issue = {
      ...options,
      number: this.nextNumber++,
      url: `https://github.com/mock/repo/issues/${this.nextNumber - 1}`,
    };
    this.createdIssues.push(issue);
    return { number: issue.number, url: issue.url };
  }

  reset(): void {
    this.createdIssues = [];
    this.nextNumber = 1000;
  }
}

/**
 * Result of incident issue creation
 */
export interface CreateIncidentIssueResult {
  created: boolean;
  issueNumber?: number;
  issueUrl?: string;
  reason?: string;
}

/**
 * Check if incident qualifies for issue creation
 */
export function shouldCreateIncidentIssue(
  state: IncidentState,
  config: IncidentConfig
): { should: boolean; reason: string } {
  // Feature must be enabled
  if (!config.createIssueOnCritical) {
    return { should: false, reason: 'feature_disabled' };
  }

  // Must be critical severity
  if (state.severity !== 'critical') {
    return { should: false, reason: 'not_critical' };
  }

  // Must be active
  if (state.currentStatus !== 'active') {
    return { should: false, reason: 'not_active' };
  }

  // Must not already have an issue
  if (state.incidentIssueCreatedAt) {
    return { should: false, reason: 'issue_already_created' };
  }

  // Must have persisted for required time
  const firstSeen = new Date(state.firstSeen);
  const now = new Date();
  const persistMs = config.criticalPersistMinutes * 60 * 1000;

  if (now.getTime() - firstSeen.getTime() < persistMs) {
    const remainingMinutes = Math.ceil(
      (persistMs - (now.getTime() - firstSeen.getTime())) / 60000
    );
    return {
      should: false,
      reason: `persist_time_not_met:${remainingMinutes}min_remaining`,
    };
  }

  return { should: true, reason: 'qualifies' };
}

/**
 * Create incident issue if conditions are met
 */
export async function createIncidentIssue(
  state: IncidentState,
  store: IIncidentStateStore,
  config: IncidentConfig,
  api: GitHubIssueAPI
): Promise<CreateIncidentIssueResult> {
  const check = shouldCreateIncidentIssue(state, config);

  if (!check.should) {
    return { created: false, reason: check.reason };
  }

  // Generate issue content
  const summary = generateIncidentSummary(state);
  const markdown = incidentToMarkdown(summary);

  const title = `[INCIDENT] ${state.severity.toUpperCase()}: ${state.incidentKey.substring(0, 8)} - ${state.topReasons[0] || 'Unknown'}`;

  const body = `## Incident Report

${markdown}

---

**Auto-generated by P17 Incident Lifecycle**

This incident has been critical for over ${config.criticalPersistMinutes} minutes.

| Metric | Value |
|--------|-------|
| First Seen | ${state.firstSeen} |
| Occurrences | ${state.occurrenceCount} |
| Correlation Key | \`${state.incidentKey}\` |

### Next Steps

1. Review the top reasons listed above
2. Check affected components
3. Reference the correlation key to find related logs
4. Update this issue with resolution steps
`;

  try {
    const result = await api.createIssue({
      title,
      body,
      labels: ['incident', 'critical', 'auto-generated'],
    });

    // Update state to record issue creation
    await markIncidentIssueCreated(store, state.incidentKey, result.number);

    return {
      created: true,
      issueNumber: result.number,
      issueUrl: result.url,
    };
  } catch (error) {
    return {
      created: false,
      reason: `api_error:${error instanceof Error ? error.message : 'unknown'}`,
    };
  }
}

/**
 * Check all critical incidents and create issues where needed
 */
export async function processIncidentIssueCreation(
  store: IIncidentStateStore,
  config: IncidentConfig,
  api: GitHubIssueAPI
): Promise<CreateIncidentIssueResult[]> {
  if (!config.createIssueOnCritical) {
    return [];
  }

  const criticalIncidents = await store.getBySeverity('critical');
  const results: CreateIncidentIssueResult[] = [];

  for (const state of criticalIncidents) {
    if (state.currentStatus === 'active' && !state.incidentIssueCreatedAt) {
      const result = await createIncidentIssue(state, store, config, api);
      results.push(result);
    }
  }

  return results;
}
